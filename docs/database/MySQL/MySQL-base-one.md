## MySQL基础架构
- MySQL可大致分：server层和存储引擎层
  - 存储引擎层架构是插件式的，常见的存储引擎有：InnoDB和MyISAM，MySQL从5.5.5版本后默认使用的存储引擎是InnoDB；
  建表时可使用engine=XXX来指定使用某个存储引擎。
  - server层包括：连接器、查询缓存、分析器、优化器、执行器等。MySQL的大多数核心服务功能和所有的内置函数都在这一层实现。_(如下示意图，图片来自：极客时间-MySQL实战45讲-基础篇-01)_
      <image src="MySQL.webp"></image>
  ### 连接器 
        当你使用：mysql -u XXX -P XXX 命令连接数据库时，接待该客户端指令的就是连接器。
- 连接器负责与客户端建立连接、获取当前用户权限、维持和管理连接。当客户端连接成功并通过验证后，连接器会读取当前登录账号拥有的权限，之后这个连接里的权限判断都依赖此时读取到的权限。
- 查询缓存：MySQL的设置中默认是关闭查询缓存的，设置参数为query_cache_type。当设置开启缓存后，MySQL拿到一个select语句回先查缓存，如果缓存中已存在直接返回结果;如果缓存中没有则继续往下查库，最后再将查询的结果放入缓存
  ，key是这条查询语句.
  - 查询缓存有着很大的弊端，只要涉及表的更新，就会触发缓存失效。因此建议关闭MySQL的全局缓存开关，只在在适当的查询sql（查询条件相对稳定，并且表数据改动机会少）语句中指定使用，如：select SQL_CACHE * from T where XXXX
- 分析器：对sql语句进行词法分析，识别出语句中的关键词（如：select），表明，字段名。然后进行语法分析，如果sql语句有语法错误会在这里报错.
  - 分析器和优化器之间会存在一个预检验的操作进行初步的权限校验，会先判断当前有没有操作表的权限。
- 优化器：对分析后sql语句进行优化，选择出系统认为的最优执行方法或者顺序。（如：语句中有多个索引，优化器会选择出自己认为最优的索引来执行；或者语句中存在多表联查，优化器会重新选择最有效率的联查顺序）。
- 执行器：使用优化后的sql，先判断当前连接的用户对于sql中的表有没有操作权限（这里相当于是对于表操作权限的再次校验，我理解主要是对于如触发器这种在执行时绕过分析器直接执行的这类语句进行校验），如果有权限，则执行器根据表引擎的定义，使用存储引擎的api接口操作。




## 事务
### 什么是事务？
事务就是要保证一组操作，要么全部成功，要么全部失败。典型的事务例子就是转账，A余额是100元，B余额0元，A给B转50元。结果要么就是转账成功，A余额变为50元，B余额变成50元。要么就是转账失败，A余额还是100元，B余额还是0元。不会出现，A余额扣款操作成功变成了50元，但B打款操作失败还是0元的情况。

### 事务的特性
事务具备四大特性：原子性（Atomicity），一致性（Consistency）， 隔离性（Isolation），持久性（Durability）
- 原子性：一个事务要么全部成功，要么全部失败
- 一致性：前后一致，由原子性、隔离性和持久性来保证一致性
- 隔离性：事务与事务之间互不影响
- 持久性：事务的改变是持久的

### Mysql如何保证事务的四大特性的

### 事务的隔离级别
- 读未提交（read uncommitted），一个事务还没提交时，它做的变更就能被别的事务看到。
- 读已提交（read committed），一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读（repeatable read），一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- 串行化（serializable ），顾名思义是对于同一行记录，写会加写锁，读会加读锁。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

### 如何开启事务？
- 显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。
- set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。
  - set autocommit=1时就是每一条语句单独包裹为一个事务。

## 索引
### 常见的索引结构有哪些
- 哈希表
  - 哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找到其对应的值即Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。
  - 哈希表对于直接等值查找时性能极其优秀，由于key非有序的原因，进行范围查找时速度极慢
- 有序数组
  - 使用有序数组的情况下，采用二分法可以快速定位需要查找的值，对于等值或者范围查找效率都极为优秀，但是对数据进行更新时需要移动后面所有记录，效率较差。
- N叉排序树
  - 对应的有AVL树、红黑树、B树以及B+树等，平衡的二叉排序树对应查询的时间复杂度为O(log(N))，更新的时间复杂度也为O(log(N))，但是数据库中由于需要考虑磁盘读写问题，都会采用N叉树的形式，比如InnoDB中采用的就是B+树。

### InnoDB中索引类型有哪些？
- 主键索引（聚簇索引）
  - 主键索引叶子节点保存整行数据
- 非主键索引（二级索引）
  - 非主键索引叶子节点保存的是主键的值
  - 通常使用非主键索引时存在回表问题（对应的额外情况为覆盖索引）。
  - 二级索引包含以下
    - 唯一索引
    - 普通索引
    - 前缀索引
    - 全文索引

### 什么是回表？
在未直接使用主键进行查询时，若是采用二级索引，首先需要根据二级索引查询到对应的主键值，然后根据主键值回到主键索引获取到对应的行数据，这种回到主键索引搜索的过程称之为回表。

### 什么是覆盖索引？
覆盖索引不是指的一种索引类型，而是达到的一种效果。在使用二级索引进行查询时，比如我们要查询对应的主键值，那么由于二级索引本身就包含了对应的主键值，根据二级索引的内容就能得到我们想要的结果，就不需要回表再查询。
- 如一个表包含三个字段，id，name，age
  - 其中id为主键索引
  - 假如拥有一个name的二级索引
    - 这条语句：select id from T where name = 'kolloge'
      - 由于二级索引里叶子节点就记录的是主键值也就是id值，那么从二级索引我们就可以得到想要查询的内容，不需要再回表查询，这样就做到了覆盖索引
    - 这条语句：select age from T where name = 'kolloge'
      - 由于二级索引里并没有age的内容，所以我们要从二级索引先查到名字为kolloge对应的id，然后使用id去主键索引里找到对应的行数据，再获取age返回，这样就进行了回表操作，没有覆盖索引
  - 假如拥有的是（name，age）的联合索引
    - 这条语句：select age from T where name = 'kolloge'
      - 由于二级索引包含有需要的内容，同样做到了覆盖索引

### 什么是Multi-Range Read(MRR)？

### InnoDB中为何会要求尽量使用自增主键索引？
- InnoDB底层采用的B+树作为索引结构，在插入新值时，如果采用自增主键，则只需要在最末尾记录处插入新纪录即可，否则若是插入位置不在最后，那么需要逻辑挪动后面的数据，空出位置。
  - TODO 补充页分裂问题以及页合并
- 同时，由于二级索引叶子节点保存的是主键索引的值，如果采用比较长的自定主键，会导致二级索引空间占用极大。采用自增主键为整型时，只需要4个字节，长整型（bigint）只需8个字节。

### 什么是online DDL？

### 什么时候考虑使用非自增的业务主键索引？
- 只有一个索引
- 该索引必须是唯一索引
这种典型的KV场景下，由于没有其他索引所以不需要考虑二级索引的叶子节点大小问题，并且这种KV形式直接设置为主键可以避免回表问题。


### 最左前缀原则
在使用联合索引时，MySQL会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 >、<、between 和 以%开头的like查询 等条件，才会停止匹配。

### 索引失效的场景

### 什么是索引下推？
- 在一个表包含三个字段，id，name，age
  - 其中id为主键索引
  - 假如拥有的是（name，age）的联合索引
  - 这条语句：select * from T where name = 'kolloge' and age = 10
    - 在MySQL 5.6之前，即使你采用了联合索引，也只是在联合索引里找到名称为kolloge的主键值，并不会去匹配age，而是到主键索引上找出数据行，再对比age字段值。
    - 而MySQL 5.6引入了索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

### Mysql中的锁有哪些？
根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类。
- 全局锁
  - 全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。
  - 全局锁的典型使用场景:做全库逻辑备份。
    - 如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。
    - 如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。
    - 官方自带的逻辑备份工具是mysqldump
      - 当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，并且设置事务级别为可重复读级别，从而拿到一致性视图。
      - 但是这种方式仅限于支持事务的引擎，相反的如MyISAM这种不支持事务的就不行。
  - 另一种全库只读的方式是set global readonly=true，但是这种方式不推荐
    - 在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大。
    - 如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。
- 表级锁
  - MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。
    - 表锁
      - 对应的语法为lock tables … read/write。可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。
    - 元数据锁MDL
      - MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。
      - MySql是在5.5版本引入的MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。
        - 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。
        - 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。