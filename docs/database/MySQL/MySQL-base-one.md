## MySQL基础架构
- MySQL可大致分：server层和存储引擎层
  - 存储引擎层架构是插件式的，常见的存储引擎有：InnoDB和MyISAM，MySQL从5.5.5版本后默认使用的存储引擎是InnoDB；
  建表时可使用engine=XXX来指定使用某个存储引擎。
  - server层包括：连接器、查询缓存、分析器、优化器、执行器等。MySQL的大多数核心服务功能和所有的内置函数都在这一层实现。_(如下示意图，图片来自：极客时间-MySQL实战45讲-基础篇-01)_
      <image src="MySQL.webp"></image>
  ### 连接器 
        当你使用：mysql -u XXX -P XXX 命令连接数据库时，接待该客户端指令的就是连接器。
- 连接器负责与客户端建立连接、获取当前用户权限、维持和管理连接。当客户端连接成功并通过验证后，连接器会读取当前登录账号拥有的权限，之后这个连接里的权限判断都依赖此时读取到的权限。
- 查询缓存：MySQL的设置中默认是关闭查询缓存的，设置参数为query_cache_type。当设置开启缓存后，MySQL拿到一个select语句回先查缓存，如果缓存中已存在直接返回结果;如果缓存中没有则继续往下查库，最后再将查询的结果放入缓存
  ，key是这条查询语句.
  - 查询缓存有着很大的弊端，只要涉及表的更新，就会触发缓存失效。因此建议关闭MySQL的全局缓存开关，只在在适当的查询sql（查询条件相对稳定，并且表数据改动机会少）语句中指定使用，如：select SQL_CACHE * from T where XXXX
- 分析器：对sql语句进行词法分析，识别出语句中的关键词（如：select），表明，字段名。然后进行语法分析，如果sql语句有语法错误会在这里报错.
  - 分析器和优化器之间会存在一个预检验的操作进行初步的权限校验，会先判断当前有没有操作表的权限。
- 优化器：对分析后sql语句进行优化，选择出系统认为的最优执行方法或者顺序。（如：语句中有多个索引，优化器会选择出自己认为最优的索引来执行；或者语句中存在多表联查，优化器会重新选择最有效率的联查顺序）。
- 执行器：使用优化后的sql，先判断当前连接的用户对于sql中的表有没有操作权限（这里相当于是对于表操作权限的再次校验，我理解主要是对于如触发器这种在执行时绕过分析器直接执行的这类语句进行校验），如果有权限，则执行器根据表引擎的定义，使用存储引擎的api接口操作。




## 事务
### 什么是事务？
事务就是要保证一组操作，要么全部成功，要么全部失败。典型的事务例子就是转账，A余额是100元，B余额0元，A给B转50元。结果要么就是转账成功，A余额变为50元，B余额变成50元。要么就是转账失败，A余额还是100元，B余额还是0元。不会出现，A余额扣款操作成功变成了50元，但B打款操作失败还是0元的情况。

### 事务的特性
事务具备四大特性：原子性（Atomicity），一致性（Consistency）， 隔离性（Isolation），持久性（Durability）
- 原子性：一个事务要么全部成功，要么全部失败
- 一致性：前后一致，由原子性、隔离性和持久性来保证一致性
- 隔离性：事务与事务之间互不影响
- 持久性：事务的改变是持久的

### Mysql如何保证事务的四大特性的

### 事务的隔离级别
- 读未提交（read uncommitted），一个事务还没提交时，它做的变更就能被别的事务看到。
- 读已提交（read committed），一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读（repeatable read），一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- 串行化（serializable ），顾名思义是对于同一行记录，写会加写锁，读会加读锁。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

### 如何开启事务？
- 显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。
- set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。
  - set autocommit=1时就是每一条语句单独包裹为一个事务。

## 索引
### 常见的索引结构有哪些
- 哈希表
  - 哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找到其对应的值即Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。
  - 哈希表对于直接等值查找时性能极其优秀，由于key非有序的原因，进行范围查找时速度极慢
- 有序数组
  - 使用有序数组的情况下，采用二分法可以快速定位需要查找的值，对于等值或者范围查找效率都极为优秀，但是对数据进行更新时需要移动后面所有记录，效率较差。
- N叉排序树
  - 对应的有AVL树、红黑树、B树以及B+树等，平衡的二叉排序树对应查询的时间复杂度为O(log(N))，更新的时间复杂度也为O(log(N))，但是数据库中由于需要考虑磁盘读写问题，都会采用N叉树的形式，比如InnoDB中采用的就是B+树。

### InnoDB中索引类型有哪些？
- 主键索引（聚簇索引）
  - 主键索引叶子节点保存整行数据
- 非主键索引（二级索引）
  - 非主键索引叶子节点保存的是主键的值
  - 通常使用非主键索引时存在回表问题（对应的额外情况为覆盖索引）。
  - 二级索引包含以下
    - 唯一索引
    - 普通索引
    - 前缀索引
    - 全文索引

### 什么是回表？
在未直接使用主键进行查询时，若是采用二级索引，首先需要根据二级索引查询到对应的主键值，然后根据主键值回到主键索引获取到对应的行数据，这种回到主键索引搜索的过程称之为回表。

### 什么是覆盖索引？
覆盖索引不是指的一种索引类型，而是达到的一种效果。在使用二级索引进行查询时，比如我们要查询对应的主键值，那么由于二级索引本身就包含了对应的主键值，根据二级索引的内容就能得到我们想要的结果，就不需要回表再查询。
- 如一个表包含三个字段，id，name，age
  - 其中id为主键索引
  - 假如拥有一个name的二级索引
    - 这条语句：select id from T where name = 'kolloge'
      - 由于二级索引里叶子节点就记录的是主键值也就是id值，那么从二级索引我们就可以得到想要查询的内容，不需要再回表查询，这样就做到了覆盖索引
    - 这条语句：select age from T where name = 'kolloge'
      - 由于二级索引里并没有age的内容，所以我们要从二级索引先查到名字为kolloge对应的id，然后使用id去主键索引里找到对应的行数据，再获取age返回，这样就进行了回表操作，没有覆盖索引
  - 假如拥有的是（name，age）的联合索引
    - 这条语句：select age from T where name = 'kolloge'
      - 由于二级索引包含有需要的内容，同样做到了覆盖索引

### 什么是Multi-Range Read(MRR)？

### InnoDB中为何会要求尽量使用自增主键索引？
- InnoDB底层采用的B+树作为索引结构，在插入新值时，如果采用自增主键，则只需要在最末尾记录处插入新纪录即可，否则若是插入位置不在最后，那么需要逻辑挪动后面的数据，空出位置。
  - TODO 补充页分裂问题以及页合并
- 同时，由于二级索引叶子节点保存的是主键索引的值，如果采用比较长的自定主键，会导致二级索引空间占用极大。采用自增主键为整型时，只需要4个字节，长整型（bigint）只需8个字节。

### 什么是online DDL？

### 什么时候考虑使用非自增的业务主键索引？
- 只有一个索引
- 该索引必须是唯一索引
这种典型的KV场景下，由于没有其他索引所以不需要考虑二级索引的叶子节点大小问题，并且这种KV形式直接设置为主键可以避免回表问题。


### 唯一索引和普通索引如何选择？
先说结论：如果字段需要唯一性要求那就优先选择唯一索引。
- 查询过程中，普通索引找到满足条件的第一个值后还会继续查后续记录，直到不满足为止，这是因为可能出现重复值的原因，但是唯一索引由于唯一性，找到后就会停止检索，但是这两者性能差距微乎其微。
  - 因为InnoDB的数据是按数据页为单位来读写的。当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在InnoDB中，每个数据页的大小默认是16KB。所以普通所以哪怕需要继续往后检索记录，很多情况下只需要一次指针寻找和一次计算。并且由于二级索引在叶子节点数据只是记录对应主键数据，如果主键设置恰当，一个数据页中是可以存放很多个KEY的。
- 更新过程中，对于InnoDB来讲，涉及到更新操作回会先判断跟新涉及的记录对应的数据页是否已经被读取到内存中，若是已经被存放在内存中，那么直接更新内存。如果没有在内存中，也不是从磁盘读取记录放到内存再修改，而是存入change buffer中，后续如果其他操作将数据页读取到内存中时，会查看是否change buffer中有涉及该数据页的操作，如果有就执行。
  - 如此减少了读磁盘的过程，这条更新语句执行效率就会更高，而这里就是唯一索引和普通索引的区别，由于唯一索引需要判断是否值是唯一，所以对应数据页如果不在内存中，那么也要从磁盘中读取出来进行比多，所以change buffer对唯一索引不起作用，提升不了效率。
  - change buffer操作应用到原数据页，得到最新结果的过程称为merge。除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中，也会执行merge操作。
  - 额外的情况
    - change buffer在merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，change buffer反而起到了副作用。
- 虽然看起来用普通索引是考虑性能之后的最优选，但其实很多业务上唯一索引牺牲的性能并不算严重，但是缺乏唯一索引进行唯一性的保证，那么就需要业务进行唯一性保证，不要太过于自信。


### 最左前缀原则
在使用联合索引时，MySQL会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 >、<、between 和 以%开头的like查询 等条件，才会停止匹配。

### 索引失效的场景

### 什么是索引下推？
- 在一个表包含三个字段，id，name，age
  - 其中id为主键索引
  - 假如拥有的是（name，age）的联合索引
  - 这条语句：select * from T where name = 'kolloge' and age = 10
    - 在MySQL 5.6之前，即使你采用了联合索引，也只是在联合索引里找到名称为kolloge的主键值，并不会去匹配age，而是到主键索引上找出数据行，再对比age字段值。
    - 而MySQL 5.6引入了索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

### Mysql中的锁有哪些？
根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类。
- 全局锁
  - 全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。
  - 全局锁的典型使用场景:做全库逻辑备份。
    - 如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。
    - 如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。
    - 官方自带的逻辑备份工具是mysqldump
      - 当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，并且设置事务级别为可重复读级别，从而拿到一致性视图。
      - 但是这种方式仅限于支持事务的引擎，相反的如MyISAM这种不支持事务的就不行。
  - 另一种全库只读的方式是set global readonly=true，但是这种方式不推荐
    - 在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大。
    - 如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。
- 表级锁
  - MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。
    - 表锁
      - 对应的语法为lock tables … read/write。可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。
    - 元数据锁MDL
      - MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。
      - MySql是在5.5版本引入的MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。
        - 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。
        - 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。
- 行锁
  - 行锁就是针对数据表中行记录的锁。事务A更新了一行，而这时候事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新。
  - MySQL的行锁是在引擎层由各个引擎自己实现的。MyISAM引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB支持行锁。
  - 两阶段锁协议
    - 在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。
    - 这个是优化点之一，由于释放锁在事务结束的时候，那么并发冲突高的加锁操作一定要放置在事务靠后位置，避免前期加锁，然后锁住较长时间。

### 死锁及死锁的处理方式
事务A对行1进行加锁后，事务B对行2进行加锁，此时事务A再去更新行2就必须等待事务B结束事务释放锁，如果事务B又要去更新行1，那么事务AB就成了互相占有并申请对方资源，造成死锁。
出现死锁之后有两个策略
- 直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。
  - 在InnoDB中，innodb_lock_wait_timeout的默认值是50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。
  - 这个时间也不能设置成一个很小的值，这样会破坏正常等待锁的情况。
- 主动死锁检测
  - 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on（默认值是on），表示开启这个逻辑。
  - 每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。
    - 这会导致并发高时给系统造成巨大的负担，因为后续进来被阻塞的事务都要进行检查，哪怕都是正常的，但是数量级上去，问题十分严重。
    - 解决这样的情况分为以下几种方式：
      - 业务自己保证不会出现死锁，关闭死锁检测。
      - 控制并发数，这种不适合在客户端做，因为客户端并发控制了，但是客户端数量多了对于数据库服务端也是巨大的压力。考虑使用中间件实现或者修改MySql源码。

### MVCC机制实现原理
MVCC（多版本并发控制）实现主要依赖于三个方面
- 隐藏字段
  - 在InnoDB存储引擎内部为每行数据添加了三个隐藏字段
    - DB_TRX_ID（6字节）：表示最后一次插入或更新该行的事务id。此外，delete操作在内部被视为更新，只不过会在记录头Record header中的deleted_flag字段将其标记为已删除。
    - DB_ROLL_PTR（7字节）：回滚指针，指向该行的undo log。如果该行未被更新，则为空。
    - DB_ROW_ID（6字节）：如果没有设置主键且该表没有唯一非空索引时，InnoDB 会使用该 id 来作为主键索引。
- ReadView
  - 为当前事务创建的快照信息
  - 主要包含以下字段
    - m_low_limit_id：目前出现过的最大的事务ID+1，即下一个将被分配的事务ID。大于等于这个ID的数据版本均不可见
    - m_up_limit_id：活跃事务列表m_ids中最小的事务ID，如果m_ids为空，则m_up_limit_id为m_low_limit_id。小于这个ID的数据版本均可见
    - m_ids：ReadView创建时其他未提交的活跃事务ID列表。创建ReadView时，将当前未提交事务ID记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的，m_ids不包括当前事务。
    - m_creator_trx_id：创建该ReadView的事务ID
- undo log
  - undo log内主要是记录的版本修改操作的逆向操作
  - 可以用于数据回滚操作
  - 同样的在MVCC中可以通过undo log来读取之前的版本的数据内容
  - undo log也分为两种
    - insert undo log
      - 由insert操作产生的undo log。因为insert操作的记录只对事务本身可见，对其他事务不可见，故该undo log可以在事务提交后直接删除。不需要进行purge操作。
    - update undo log
      - update或delete操作中产生的undo log。该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程 进行最后的删除。

### RR及RC级别MVCC分别的作用
在RR级别下
- 一个事务开启时如果只是普通的begin/start transaction，那么此时并没有真正的启动事务，所以也不会为该事务创建ReadView。直到执行第一个操作表的语句事务才启动。
- 而采用start transaction with consistent snapshot 则会直接创建事务的ReadView。并且在RR级别下，第一次创建ReadView直到事务结束都会一直使用这个ReadView。
- 只读事务begin/start transaction read only 是不会给事务分配事务id的，别的情况，进行select操作是会分配事务id的。
- 一个查询语句进来的流程：
  - 对于查询的行a，查看行a的隐藏字段DB_TRX_ID来获取最后更新该行的事务。
  - 拿到对应行的事务id到ReadView中做对比
    - 若行事务id大于等于m_low_limit_id也就是ReadView记录的最大限制id，那么可以直接判断这条数据其实应该不可见，去undo log查找历史数据
    - 若行事务id小于m_up_limit_id也就是ReadView记录的最小事务ID，那么证明这条数据肯定是已提交事务修改的，可见，直接使用。
    - 若事务id在以上两者范围内，那么就去对比m_ids活跃事务id列表，
      - 若该事务id在列表中，那么处于活跃态，不可见
      - 若不在，那么要么已提交要么自身，所以可见
  - 对于不可见情况，获取记录行的DB_ROLL_PTR指针所指向的undo log取出快照记录，用快照记录的DB_TRX_ID进行上述判断，找到可见的版本返回。
- 而对于update操作，更新数据都是先读后写，读是当前读。
  - 所以一种情况事务A先查询行1的字段a值为1，随后事务B更新了该行字段a值跟新为2，而随后事务A也更新了操作为a=a+1，由于更新操作时当前读，所以操作之后值会是3，此时事务A再次执行相同的查询语句，由于该行是被自己更新的，所以会查到最新的a值3。

在RC级别下：类似于RR级别差异点在于每一个语句执行前重新创建一个ReadView。